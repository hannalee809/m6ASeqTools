---
title: "Introduction to m6ASeqTools"
author: "Hanna Lee"
date: "`r Sys.Date()`"
output:
   rmarkdown::html_document:
    toc: true
    toc_depth: 2 
    toc_float: true
    theme: flatly
vignette: >
  %\VignetteIndexEntry{Introduction to m6ASeqTools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,       # show R code
  message = FALSE,   # suppress messages
  warning = FALSE,   # suppress warnings
  progress = FALSE   # hide knit progress lines
)
```

# Introduction
`m6ASeqTools` is an R package designed to streamline the post-processing and interpretation of site-level m6A predictions from m6Anet. It provides descriptive summaries of m6A distribution across transcripts, genes, biotypes, and transcript regions, and enables condition comparisons through a calculated weighted modification ratio. By integrating differential gene expression data, the package links methylation changes with expression differences, providing biotype-specific and region-specific insights into how m6A localization patterns relate to transcriptional regulation.

# Installation
`m6ASeqTools` can be installed on **Windows, macOS, and Linux**. It requires R (≥4.0).

```{r installation, eval=FALSE}
# Install devtools if needed
install.packages("devtools")

# Install Bioconductor dependencies
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(c(
    "AnnotationDbi",
    "org.Hs.eg.db",
    "GenomicFeatures",
    "GenomicRanges",
    "IRanges",
    "S4Vectors"
))

# Install m6ASeqTools from GitHub
devtools::install_github("hannalee809/m6ASeqTools")
```

# Input Data

The first step in using **m6ASeqTools** is importing the `data.site_proba.csv` file, which represents the final output from **m6Anet**. The columns include:

1. **m6A site information**

    - `ensembl_transcript_id`: Ensembl transcript identifier
    - `ensembl_gene_id`: Ensembl gene identifier
    - `otthumg_gene_id` / `otthumg_transcript_id`: Optional human gene/transcript IDs for cross-referencing
    - `ensembl_transcript_name` / `ensembl_gene_name`: Human-readable transcript and gene names
    - `transcript_length`: Length of the transcript in nucleotides
    - `gene_biotype`: Biotype of the transcript (e.g., protein_coding, lncRNA)
    - `transcript_position`: Position of the m6A site within the transcript

2. **Read coverage**

    - `n_reads`: Number of reads covering the m6A site

3. **Modification information**

    - `probability_modified`: Predicted probability of modification at the site (0–1)
    - `kmer`: Sequence k-mer context surrounding the modified nucleotide
    - `mod_ratio`: Observed modification ratio (0–1), reflecting the proportion of reads supporting the modification

> **Note:** Some columns in the raw file contain multiple values combined with a `|` separator. These must be split before using the data with this package.

For this tutorial, we provide two example datasets:

1. 100 predicted m6A sites from the **Gli36** glioma cell line.  
2. 100 predicted m6A sites from the same cell line following **IGF2BP2 siRNA knockdown**.

These example datasets allow you to explore the package workflow without needing your own experimental data.

```{r import-data, echo=FALSE}
library(kableExtra)
library(m6ASeqTools)
```

```{r example-data-load}
# Load the example dataset included in the package
data("example_m6A_naive_gli36_cells")
head(example_m6A_naive_gli36_cells)
```

# Descriptive Statistics

## Summary Report of m6Anet Output

After importing the `data.site_proba.csv` file in the required format, you can generate a summary report using the `summarize_m6anet_output()` function. This function produces an HTML report that includes the following:

1. **Overview table:** Total number of detected m6A sites, transcripts, and genes, as well as the number of sites, transcripts, and genes with a **modification probability > 90%**. These high-confidence sites are filtered and used for the rest of the report, and they should also be used for downstream analyses.
2. **High-confidence sites per transcript:** Table and histogram showing the distribution of the number of high-confidence sites per transcript.
3. **High-confidence transcripts per gene:** Table and histogram showing the distribution of high-confidence transcripts per gene.
4. **Transcript biotype distribution:** Table and pie chart(s) showing counts and frequencies of high-confidence transcripts by biotype.
5. **Modified k-mer distribution:** Table and bar graph showing counts and frequencies of modified k-mers.
6. **Transcript length distribution:** Table and density graph showing the lengths of modified transcripts, grouped into bins: 101–500 bp, 501–1000 bp, 1001–5000 bp, 5001–10000 bp, and >10000 bp.

```{r summarize-m6anet-output, eval=FALSE}
# Generate the summary HTML report
summarize_m6anet_output(
  example_m6A_naive_gli36_cells, 
  output_file = "naive_summary_report.html"
)
```

```{r summary-plot, echo=FALSE, out.width="100%", out.height="800px"}
knitr::include_graphics("naive_html_summary.png")
```

## Filter m6A Sites
m6Anet recommends retaining sites with probability_modified > 0.9.
This function applies a user-defined threshold (default = 0.9) and returns the filtered dataset.

> **Important:** Use this filtered dataset from this point onward for downstream analyses.

```{r filter-m6a, eval = FALSE}
filtered_m6A_naive_gli36_cells <- filter_m6a_sites(example_m6A_naive_gli36_cells,
                                       probablity_modified=0.9)
```

## Transcript Region Analysis
These functions allow you to:

1. **Assign each m6A site to a transcript region**  
   (5'UTR, CDS, or 3'UTR)

2. **Compute its relative position within that region**, scaled 0–1.
This

3. **Visualize the global distribution of m6A** across these regions using a kernel density plot.

This workflow requires a GTF annotation file.

```{r tx-regions, eval = FALSE}
# Path to GTF annotation file
gtf_path <- "/path/to/gencode.v45.annotation.gtf"

# Step 1: Extract transcript region lengths (5'UTR, CDS, 3'UTR)
tx_df <- get_transcript_region_lengths(gtf_path)

# Step 2: Annotate each m6A site with its region and relative position
filtered_m6A_naive_gli36_cells <-
  map_relative_tx_regions_to_m6A(
    filtered_m6A_naive_gli36_cells,
    tx_df
  )

# Step 3: Visualize distribution of m6A across transcript regions
p <- plot_relative_positions(filtered_m6A_naive_gli36_cells, label = "naive") # add plot label if desired
```

The output includes the original m6A site information along with transcript-region annotations (5′UTR, CDS, 3′UTR). For each region, the table reports its length, start and end positions, the region in which the site falls, and the site’s relative position within that region. Some sites may not map to any transcript region (i.e., sites on non-coding transcripts with no annotated UTR/CDS structures). These sites are retained in the output, with `NA` values for the transcript-region fields.

```{r tx-region-table, echo=FALSE}
knitr::kable(
data.frame(
m6a_site_info... = c("..."),
utr5_length = "159",
utr3_length = "1457",
cds_length_tx = "834",
start_utr5 = "1",
end_utr5 = "159",
start_cds = "160",
end_cds = "992",
start_utr3 = "993",
end_utr3 = "2449",
isin_5utr = "0",
isin_cds = "0",
isin_3utr = "1",
rel_5utr = "NA",
rel_cds = "NA",
rel_3utr = "0.78"
),
align="l"
) %>% 
  kable_styling(
    font_size = 10,
    full_width = FALSE
  )
```

```{r tx-plot, echo=FALSE, out.width="80%", out.height="400px"}
knitr::include_graphics("Transcript_Region_Density_naive.png")
```

## Chromosomal Annotation and Distribution
This function assigns each m6A site to its chromosome using human gene annotations from org.Hs.eg.db. Provide the m6A dataframe and optionally specify whether the results should be saved as a CSV and whether a chromosomal distribution plot should be generated.

```{r chr-dist, eval=FALSE}
calculate_chromosome_location(filtered_m6A_naive_gli36_cells,
                              output_csv=NULL, 
                              output_plot="naive_chr_distribution.png")
```

```{r chr-plot, echo=FALSE, out.width="80%", out.height="400px"}
knitr::include_graphics("naive_chr_distribution.png")
```

## Weighted Modification Ratio Calculation
This metric summarizes transcript-level methylation by combining the number of modified sites, their modification ratios, and transcript length. You can either input the m6a dataframe or the annotated output from map_relative_tx_regions_to_m6A(), as this will provide a regional summary in addition to the weighted modificaition ratio calculation.

The **weighted modification ratio** per transcript is defined as:

$$
\text{Weighted Modification Ratio} = \frac{\sum_{i=1}^{n} r_i}{L}
$$

where:  

- \(r_i\) = modification ratio at site \(i\)  
- \(n\) = number of m6A sites in the transcript  
- \(L\) = length of the transcript (in nucleotides)

The function returns a dataframe containing one row per transcript with:

- total modification ratio across all sites
- counts of sites in 5′UTR, CDS, and 3′UTR (if `tx_info` = TRUE)
- the computed weighted modification ratio

```{r calc-wmr, eval=FALSE}
calculate_weighted_mod_ratio(filtered_m6A_naive_gli36_cells, mod_ratio_column = "mod_ratio")
```

```{r wmr-table, echo=FALSE}
library(kableExtra)

knitr::kable(
  data.frame(
    m6a_transcript_info... = c("...", "..."),
    sum_mod = c("1.81", "1.79"),
    n_sites = c("3", "3"),
    sites_in_5utr = c("0", "0"),
    sites_in_cds = c("0", "0"),
    sites_in_3utr = c("3", "3"),
    weighted_mod_ratio = c("0.00075", "0.00067")
  ),
  align = "l"
) %>%
  kable_styling(
    font_size = 11,
    full_width = FALSE
  )
```

# Incorporating External Annotations
This part of the package provides tools to convert m6Anet transcript-based coordinates into genomic coordinates using GTF annotations. The resulting genomic positions can be exported as a BED file, enabling direct visualization of m6A sites in genome browsers such as IGV or UCSC Genome Browser. In addition, a secondary function allows users to annotate their m6A BED file with any user-provided BED datasets, making it easy to integrate external features such as RBP peaks, miRNA binding sites, SNPs, or other genomic intervals.

## Converting m6Anet Transcript Coordinates to Genomic Coordinates and Creating BED Files:
m6Anet reports modification sites using transcript-based positions, which cannot be directly viewed in genome browsers. To enable genomic visualization and downstream annotation, the package includes a function that:

- maps transcript positions to genomic coordinates using a user-provided GTF annotation
- generates standard BED6 and BedGraph tables
- optionally writes these to files for IGV/UCSC Genome Browser

This enables seamless integration of m6A site calls with external genomic features such as RBP binding sites, miRNA binding sites, SNPs, or any other interval-based annotation.

Inputs:

- **data.site_proba_df:** m6Anet output; must include ensembl_transcript_id, transcript_position, ensembl_gene_name, mod_ratio.
- **gtf_path:** path to a GENCODE/Ensembl GTF (or GFF3) annotation.
- **output_bed:**  optional path to write the BED6 file.
- **output_bedgraph:** optional path to write the BedGraph file.

```{r bed-file, eval=FALSE}
create_bed_file(
  filtered_m6A_naive_gli36_cells,
  gtf_path,
  output_bed = "path/to/ouput/bed",
  output_bedgraph = "path/to/output/bedgraph"
)
```

Outputs:

1. m6a_df_with_genomic_coordinates

    - transcript-level positions mapped to chr, genomic_pos, and strand.
    - the `name` column is automatically constructed as transcriptID_position (e.g., ENST00000335137_1285).
    - `score`: mod_ratio * 1000  (for IGV visualization of m6A levels)

2. bed_df: ready-to-visualize BED6 data frame.
3. BED6 and BEDGRAPH files saved to user-provided path.


```{r bed-format, echo=FALSE}
knitr::kable(
data.frame(
chr = c("chr1", "chr1", "chr2"),
start = c(10048291, 10599321, 20488511),
end = c(10048292, 10599322, 20488512),
name = c("ENST00000335137_1285",
"ENST00000284987_452",
"ENST00000491231_97"),
score = c(820, 640, 995),
strand = c("+", "-", "+")
),
caption = "Example BED6 output generated by create_bed_file()"
)
```

This figure shows an example of m6A visualization in IGV using the generated bedGraph file. m6A levels are represented by the score track. The view is zoomed into chromosome 17, where the pink signal reflects m6A levels and the blue track shows the gene annotation.
 
```{r igv-plot, echo=FALSE, out.width="100%", out.height="200px"}
knitr::include_graphics("naive_m6a_igv_chr17.png")
```

## Annotating m6A Sites with External Genomic Features

This section demonstrates how to annotate m6A sites using user-provided genomic feature files (e.g., RBP binding sites, miRNA targets, SNPs, enhancers, promoters). The annotate_m6A_overlaps() function accepts any BED-like table as long as genomic coordinates and a feature column are supplied.

The function takes two inputs:

1. **m6A bed table** with chromosome, start, end, and strand (from `create_bed_file()`)
2. **Annotation table** with genomic intervals (chr, start, end, strand) and a feature label (e.g., RBP_name, SNP_ID, miRNA_ID)

> **Note:** Both inputs should use the same coordinate system — either 0-based or 1-based. By default, the function assumes 0-based coordinates (`zero_based` = TRUE). If your input tables use 1-based coordinates, set `zero_based` = FALSE.

Both inputs are internally converted to `GenomicRanges` objects. If `zero_based = TRUE`, the coordinates are automatically converted from 0-based to 1-based as required by `GenomicRanges`. Overlaps are computed using `findOverlaps()`, and all annotation metadata columns are retained. Strand matching can be required or ignored depending on the use case.

The function returns two data frames:

1. **overlap_df** containing row-level overlaps

    - `m6A_index`: index of the m6A site, corresponds with the row ID in the original m6A dataframe
    - Feature name (from `feature_col`)
    - All additional annotation metadata columns 

2. **annotated_m6A_df**

    - Original m6A site information
    - Overlapping_Features: semicolon-separated list of feature names
    - Feature_Count: number of unique overlapping features
    
```{r annotate-m6A-example, message=FALSE, warning=FALSE}
# Step 1: Load example BED file for Naive Gli36
data("example_m6A_naive_gli36_BED")
```

```{r show-naive-bed, echo=FALSE}
knitr::kable(head(example_m6A_naive_gli36_BED), 
             caption = "First 6 rows of example m6A BED file")
```

```{r load-example-rbp}
# Step 2: Load example RBP annotation
data("example_rbp_annotation")

# Define columns
colnames(example_rbp_annotation) <- c(
"chr", "start", "end", "peak_id", "strand",
"RBP_name", "experiment_method", "sample",
"accession_of_raw_data", "conf_score"
)
```

```{r show-rbp-bed, echo=FALSE}
knitr::kable(head(example_rbp_annotation),
caption = "First 6 rows of example RBP annotation") %>%
  kableExtra::kable_styling(font_size = 11)
```

```{r run-annotation,message=FALSE, warning=FALSE}
# Step 3: Run annotation function
annotated_example_naive_with_rbp <- annotate_m6a(
example_m6A_naive_gli36_BED,
example_rbp_annotation,
feature_col = "RBP_name"
)
```

Here are the outputs of the function:
```{r annotation-output01, echo=FALSE}
knitr::kable(head(annotated_example_naive_with_rbp$overlap_df),
caption = "First 6 rows of overlap between m6A sites and RBP annotations") %>%
  kableExtra::kable_styling(font_size = 11)
```

```{r annotation-output02, echo=FALSE}
knitr::kable(head(annotated_example_naive_with_rbp$annotated_m6A_df),
caption = "First 6 rows of summarized annotated m6A sites") %>%
  kableExtra::kable_styling(font_size = 11)
```

Both output dataframes include a reference to the original m6A sites. In `overlap_df`, the first column `m6a_index` directly corresponds to the m6A site identifier from the input BED file, providing a one-to-one mapping for each overlap with RBPs. In `annotated_m6A_df`, the first column is a `row_id` that references the row of the original m6A dataframe. This allows users to easily merge the summarized annotation back with their original m6A dataset for downstream analyses. Essentially, `overlap_df` gives a detailed, long-format view of individual overlaps, while `annotated_m6A_df` provides a compact summary with a direct link to the original m6A sites.

# Comparative Analysis

Because m6Anet outputs predictions for individual samples, this package adds tools for comparing m6A patterns across conditions. The main capabilities include:

1. Shared vs. condition-specific features: Summaries of common and unique m6A sites, transcripts, and genes between groups.
2. Differential methylation analysis

    - No replicates: computes a weighted modification ratio for each transcript and compares conditions using a log2 fold-change to highlight transcripts with clear shifts in methylation.
    - With replicates: runs a Wilcoxon rank-sum test on weighted modification ratios to identify transcripts showing statistically significant hypermethylation in one condition.

3. Integration with differential gene expression: Results can be merged with DE analyses for joint interpretation.
4. Functional categorization: Transcripts are grouped into six classes reflecting combined methylation and expression behavior (e.g., hypermethylated + upregulated, hypermethylated + unchanged). For each class, the package reports transcript biotypes and m6A site distributions across transcript regions, providing structured biological context.

## Comparing m6A Distributions Across Samples

Understanding how m6A sites, transcripts, or genes differ between samples is often the first step in comparative methylation analysis. The compare_m6a_distribution() function provides a simple way to quantify shared and unique features across two or more groups.

This function takes a **named list**, where each element contains a vector of m6A site IDs, transcript IDs, or gene IDs for each condition. It returns a structured summary of overlaps and differences, including:

- Unique elements per group
- Pairwise intersections: shared elements between every pair of groups
- Common elements across all groups
- For exactly 3 groups, the function also reports elements that are shared by two groups but absent from the third.

```{r compare-m6a}
# Comparing the m6A distribution between IGF2BP2 KD and Naive

# Load IGF2BP2 data
data("example_m6A_igf_gli36_cells")

# Create m6A site list
example_m6A_igf_gli36_cells$site <- paste(example_m6A_igf_gli36_cells$ensembl_transcript_id, example_m6A_igf_gli36_cells$transcript_position, sep = "_") # creates a unique site identifier

example_m6A_naive_gli36_cells$site <-  paste(example_m6A_naive_gli36_cells$ensembl_transcript_id, example_m6A_naive_gli36_cells$transcript_position, sep = "_")

site_list <- list(igf = unique(example_m6A_igf_gli36_cells$site),
                  naive = unique(example_m6A_naive_gli36_cells$site))

# Create m6A transcript list
tx_list <- list(igf = unique(example_m6A_igf_gli36_cells$ensembl_transcript_name),
                  naive = unique(example_m6A_naive_gli36_cells$ensembl_transcript_name))

# Create m6A gene list
gene_list <- list(igf = unique(example_m6A_igf_gli36_cells$ensembl_gene_name),
                  naive = unique(example_m6A_naive_gli36_cells$ensembl_gene_name))

# Run function
#common_unique_sites <- compare_m6a_distribution(site_list)
#common_unique_tx <- compare_m6a_distribution(tx_list)
common_unique_genes <- compare_m6a_distribution(gene_list)

# Distribution values
attr(common_unique_genes, "summary")

# Show common sites
common_unique_genes$common_all
```

## Differential Methylation (No Replicates)

Using the weighted modification ratios produced by calculate_weighted_mod_ratio(), this function merges two transcript-level data frames, keeps only transcripts present in both groups, and computes the log2 fold change in weighted modification ratio. Although observational, this metric highlights transcripts that appear hypermethylated in one condition relative to the other. This is especially useful when integrating methylation changes with gene expression to identify regulatory patterns across conditions.

The inputs of this function are the dataframes for Group 1 and Group 2 that contain the `weighted_mod_ratio` column. 

> **Note:** If you plan to run **Differential Methylation and Gene Expression**, make sure to run `map_relative_tx_regions_to_m6a()` before `calculate_weighted_mod_ratio()`. This ensures transcript-region annotations are included in the downstream dataframes.

This function returns a merged dataframe containing:

- Core m6A transcript data (transcript ID, gene ID, length, biotype)
- Weighted modification ratios (WMR) for each condition
- The log2 fold change of the WMR, using condition 1 as the numerator.

    - Positive values indicate higher methylation in condition 1
    - Negative values indicate higher methylation in condition 2

```{r wmr}
# Load example dataframes with the weighted modification ratio calculations
data("naive_gli36_cells_wmr")
data("igf_gli36_cells_wmr")

# Show first few lines
head(naive_gli36_cells_wmr)

# Run function
logfc_wmr_igf_vs_naive <- log2fc_weighted_mod_ratio(group1_df = igf_gli36_cells_wmr, # IGF set as condition 1
                                                    group2_df = naive_gli36_cells_wmr) # Naive set as condition 2

head(logfc_wmr_igf_vs_naive)
```

From the first few lines of the output, we notice that these specific transcripts are positive and therefore hypermethylated in the IGF2BP2 KD condition compared to the Naive.

## Differential Methylation (With Replicates)
If your study includes replicates, this function performs a Wilcoxon rank-sum test to assess whether a transcript shows higher or lower methylation between two conditions. Use the raw, unfiltered m6A site-level data so that all potential modification sites are represented. This ensures accurate aggregation and avoids bias introduced by pre-filtering.

This function will undergo the following key steps:

1. Combining replicates for each condition
2. Filtering out transcripts with zero WMR across all replicates
3. Calculating per-transcript median WMR for each condition
4. Running a Wilcoxon rank-sum test between conditions
5. Returning transcript metadata and differential statistics

You must provide two lists:

- `condition1_list`: list of data frames for condition 1
- `condition2_list`: list of data frames for condition 2

Each data frame must include these columns:

- `ensembl_transcript_name`
- `ensembl_transcript_id`
- `ensembl_gene_id`
- `ensembl_gene_name`
- `gene_biotype`
- `transcript_length`
- `weighted_mod_ratio`

```{r run_differential_test, eval=F}
# Define lists
naive_list <- list(naive1_wmr, naive2_wmr, naive3_wmr)
igf_list <- list(igf1_wmr, igf2_wmr, igf3_wmr)

# Function call
results <- run_wmr_differential_test(
condition1_list = naive_list,
condition2_list = igf_list,
condition1_name = "naive",
condition2_name = "IGF"
)
```

The output of this function is a data frame containing one row per transcript with

- Transcript metadata
- `median_wmr_condition1`
- `median_wmr_condition2`
- `median_diff` (condition2 − condition1). A positive `median_diff` means higher median WMR in the second condition.
- `p_value` from Wilcoxon test. Low `p_value` indicates statistical significance.

```{r wilcox_output, echo=FALSE}
knitr::kable(
data.frame(
ensembl_transcript_name = c("JKAMP-213", "PHPT1-204"),
ensembl_transcript_id = c("ENST00000602482.5", "ENST00000463215.1"),
ensembl_gene_id = c("ENSG00000050130.18", "ENSG00000054148.18"),
ensembl_gene_name = c("JKAMP", "PHPT1"),
gene_biotype = c("retained_intron", "protein_coding_CDS_not_defined"),
transcript_length = c("2302", "627"),
median_wmr_condition1 = c("0.0011716045", "0.0001362911"),
median_wmr_condition2 = c("0", "0"),
median_diff = c("-1.171604e-03", "-1.362911e-04"),
p_value = c("0.0765225", "0.0765225")),
align="l", 
caption = "Example output from run_wmr_differential_test()"
) %>% 
  kable_styling(
    font_size = 10,
    full_width = FALSE
  )
```

## Differential Methylation and Gene Expression

After running the differential methylation analysis (either with or without replicates), you can incorporate differential gene expression results (i.e. DESeq2) to determine these 6 clusters of m6A and expression.

1. Hypermethylated in Condition 1, Upregulated in Condition 1
2. Hypermethylated in Condition 2, Upregulated in Condition 2
3. Hypermethylated in Condition 1, Upregulated in Condition 2
4. Hypermethylated in Condition 2, Upregulated in Condition 1
5. Hypermethylated in Condition 1, No significant change in gene expression
6. Hypermethylated in Condition 2, No significant change in gene expression

This function can be run with either the output from `log2fc_weighted_mod_ratio()` or `run_wmr_differential_test()`, just the arguments will differ depending on which one you use. 

**For a study with no replicates:**



## Summary of Methylation and Expression

# Combined Functions (Part 1 & 2)






