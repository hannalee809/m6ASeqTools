chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000
strand=strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
colnames(merged_naive_m6a_with_genomic_coords)
# merge with original m6A df
merged_naive_m6a_with_genomic_coords <- merge(
pooled_naive,
naive_gr_genomic_coords,
by.y = c("ensembl_transcript_id", "original_m6a_row_index"),
by.x = c("ensembl_transcript_id", "row_id")
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
View(merged_naive_m6a_with_genomic_coords)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
colnames(merged_naive_m6a_with_genomic_coords)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start = genomic_pos - 1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
"genomic_pos" %in% colnames(merged_naive_m6a_with_genomic_coords)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
# BED Field 1: Chromosome
chr = chr,
# BED Field 2: Start (0-based)
# Subtract 1 from the 1-based genomic_pos
start = genomic_pos - 1,
# BED Field 3: End (1-based, half-open)
# The end coordinate is the 1-based position itself
end = genomic_pos,
# BED Field 4: Name (Required identifier)
name = ensembl_gene_name,
# BED Field 5: Score (Scaled 0-1000 for IGV color)
score = mod_ratio * 1000,
# BED Field 6: Strand
strand = strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
# BED Field 1: Chromosome
chr = chr,
# BED Field 2: Start (0-based)
# Subtract 1 from the 1-based genomic_pos
start = "genomic_pos" - 1,
# BED Field 3: End (1-based, half-open)
# The end coordinate is the 1-based position itself
end = genomic_pos,
# BED Field 4: Name (Required identifier)
name = ensembl_gene_name,
# BED Field 5: Score (Scaled 0-1000 for IGV color)
score = mod_ratio * 1000,
# BED Field 6: Strand
strand = strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
mutate(
start = genomic_pos - 1,
end = genomic_pos,
score = mod_ratio * 1000
) %>%
select(
chr,
start,
end,
name = ensembl_gene_name,
score,
strand
)
View(naive_bed)
output_file <- "pooled_naive_m6a_genomic_igv.bed"
write.table(naive_bed,
file = output_file,
sep = "\t",
quote = FALSE,
row.names = FALSE,
col.names = FALSE)
problem_rows <- naive_bed %>%
dplyr::filter(is.na(name) | is.na(score) | is.na(strand))
str(naive_bed)
naive_bedgraph <- merged_naive_m6a_with_genomic_coords %>%
transmute(
chr,
start = genomic_pos - 1,
end = genomic_pos,
score = mod_ratio
)
write_tsv(naive_bedgraph, "naive_m6A_ratio.bedgraph", col_names = FALSE)
write.table(
naive_bedgraph,
file = "naive_m6A_ratio.bedgraph",
sep = "\t",
quote = FALSE,
row.names = FALSE,
col.names = FALSE
)
filt_pooled_naive <- filter_m6a_sites(pooled_naive)
library(m6ASeqTools)
filt_pooled_naive <- filter_m6a_sites(pooled_naive)
sites_per_tx <- filt_pooled_naive %>%
group_by(ensembl_transcript_id) %>%
summarize(n=n())
View(sites_per_tx)
View(sites_per_tx)
sites_per_tx <- filt_pooled_naive %>%
group_by(ensembl_transcript_name) %>%
summarize(n=n())
sites_per_tx <- pooled_naive %>%
group_by(ensembl_transcript_name) %>%
summarize(n=n())
View(sites_per_tx)
#' Load built-in RBP annotation
#'
#' @param organism "human" or "mouse"
#' @return GRanges object of RBP binding sites
#' @export
load_RBP_annotation <- function(organism = c("human", "mouse")) {
organism <- match.arg(organism)
file <- switch(organism,
"human" = system.file("extdata", "human_RBP_hg38.bed", package = "m6ASeqTools"),
"mouse" = system.file("extdata", "mouse_RBP_mm10.bed", package = "m6ASeqTools")
)
rtracklayer::import(file)
}
human_rbp_annotation <- load_RBP_annotation("human")
rbp_human_df <- readr::read_tsv(
"/Users/hannalee2002/Downloads/POSTAR3_downloads/human.txt",
col_names = c(
"chrom", "start", "end", "peak_id", "strand",
"rbp", "method", "sample", "accession", "score"
)
)
head(rbp_human_df)
# Convert m6A data to GRanges
# Start is 0-based in the file, but GRanges expects 1-based data,
# so we use start + 1 for the 1-based coordinate.
naive_bed_1_based_coord <- GRanges(
seqnames = naive_bed$chr,
ranges = IRanges(start = naive_bed$start + 1,
end = naive_bed$end),
strand = naive_bed$strand,
m6a_name = naive_bed$name,
m6a_score = naive_bed$score
)
rbp_human_gr <- GRanges(
seqnames = rbp_human_df$chrom,
ranges = IRanges(start = rbp_human_df$start,
end = rbp_human_df$end),
# Strand is important for RBP binding
strand = rbp_human_df$strand,
# Add RBP information as metadata
rbp_name = rbp_human_df$rbp,
rbp_method = rbp_human_df$method,
rbp_accession = rbp_human_df$accession,
rbp_score = rbp_human_df$score
)
rbp_human_gr <- GRanges(
seqnames = rbp_human_df$chrom,
ranges = IRanges(start = rbp_human_df$start + 1, # convert from 0-based to 1-based
end = rbp_human_df$end),
# Strand is important for RBP binding
strand = rbp_human_df$strand,
# Add RBP information as metadata
rbp_name = rbp_human_df$rbp,
rbp_method = rbp_human_df$method,
rbp_accession = rbp_human_df$accession,
rbp_score = rbp_human_df$score
)
# Find overlaps between m6A sites (query) and RBP sites (subject)
# 'ignore.strand=FALSE' is critical, as RBP binding is strand-specific.
overlaps <- findOverlaps(query = naive_m6A_gr,
subject = rbp_human_gr,
ignore.strand = FALSE)
# Convert m6A data to GRanges
# Start is 0-based in the file, but GRanges expects 1-based data,
# so we use start + 1 for the 1-based coordinate.
naive_m6A_gr <- GRanges(
seqnames = naive_bed$chr,
ranges = IRanges(start = naive_bed$start + 1, # convert 0-based to 1-based
end = naive_bed$end),
strand = naive_bed$strand,
m6a_name = naive_bed$name,
m6a_score = naive_bed$score
)
# Find overlaps between m6A sites (query) and RBP sites (subject)
# 'ignore.strand=FALSE' is critical, as RBP binding is strand-specific.
overlaps <- findOverlaps(query = naive_m6A_gr,
subject = rbp_human_gr,
ignore.strand = FALSE)
# Extract the indices:
# queryHits are the row numbers in the m6a_gr object (your m6A sites)
m6a_indices <- queryHits(overlaps)
# subjectHits are the row numbers in the rbp_gr object (the RBP sites)
rbp_indices <- subjectHits(overlaps)
length(m6a_indices)
nrow(naive_m6A_gr)
length(naive_m6A_gr)
# 1. Create a data frame containing only the overlapping records
overlap_df <- data.frame(
# Unique identifier for the m6A site that overlapped
m6a_row_index = m6a_indices,
# Metadata from the overlapping RBP site
RBP_Name = rbp_gr$rbp_name[rbp_indices],
RBP_Method = rbp_gr$rbp_method[rbp_indices],
RBP_Accession = rbp_gr$rbp_accession[rbp_indices]
) %>%
# Group by the m6A site index and summarize the RBP data
group_by(m6a_row_index) %>%
dplyr::summarise(
# Create a comma-separated list of all overlapping RBPs for that m6A site
Overlapping_RBPs = paste(unique(RBP_Name), collapse = "; "),
# Count how many unique RBPs overlap the site
RBP_Count = n_distinct(RBP_Name),
.groups = 'drop'
)
# 1. Create a data frame containing only the overlapping records
overlap_df <- data.frame(
# Unique identifier for the m6A site that overlapped
m6a_row_index = m6a_indices,
# Metadata from the overlapping RBP site
RBP_Name = rbp_human_gr$rbp_name[rbp_indices],
RBP_Method = rbp_human_gr$rbp_method[rbp_indices],
RBP_Accession = rbp_human_gr$rbp_accession[rbp_indices]
) %>%
# Group by the m6A site index and summarize the RBP data
group_by(m6a_row_index) %>%
dplyr::summarise(
# Create a comma-separated list of all overlapping RBPs for that m6A site
Overlapping_RBPs = paste(unique(RBP_Name), collapse = "; "),
# Count how many unique RBPs overlap the site
RBP_Count = n_distinct(RBP_Name),
.groups = 'drop'
)
View(overlap_df)
isu_all <- read.csv("/Users/hannalee2002/hl_cell-lines-project/cell-lines-ISU/all_ISU_KD_naive.csv")
head(isu_all)
isu_alk_naive <- isu_all %>%
filter(condition_1 == "ALK", condition_2 = "NAIVE")
isu_alk_naive <- isu_all %>%
filter(condition_1 == "ALK", condition_2 == "NAIVE")
isu_igf_naive <- isu_all %>%
filter(condition_1 == "IGF", condition_2 == "NAIVE")
isu_naive <- su_all %>%
filter(condition_2 == "NAIVE")
isu_naive <- isu_all %>%
filter(condition_2 == "NAIVE")
ggplot(data=isu_naive, aes(x=gene_log2_fold_change, y=dIF)) +
geom_point(
aes( color=abs(dIF) > 0.1 & isoform_switch_q_value < 0.05 ), # default cutoff
size=1
) +
facet_wrap(~ condition_2) +
#facet_grid(condition_1 ~ condition_2) + # alternative to facet_wrap if you have overlapping conditions
geom_hline(yintercept = 0, linetype='dashed') +
geom_vline(xintercept = 0, linetype='dashed') +
scale_color_manual('Signficant\nIsoform Switch', values = c('black','red')) +
labs(x='Gene log2 fold change', y='dIF') +
theme_bw()
library(ggplot2)
library(ggplot2)
p<-ggplot(data=isu_naive, aes(x=gene_log2_fold_change, y=dIF)) +
geom_point(
aes( color=abs(dIF) > 0.1 & isoform_switch_q_value < 0.05 ), # default cutoff
size=1
) +
facet_wrap(~ condition_2) +
#facet_grid(condition_1 ~ condition_2) + # alternative to facet_wrap if you have overlapping conditions
geom_hline(yintercept = 0, linetype='dashed') +
geom_vline(xintercept = 0, linetype='dashed') +
scale_color_manual('Signficant\nIsoform Switch', values = c('black','red')) +
labs(x='Gene log2 fold change', y='dIF') +
theme_bw()
create_bed_file <- function(data.site_proba_df,
gtf_path,
output_bed = NULL,
output_bedgraph = NULL) {
# Create the Transcript Database (TxDb) from gtf_path
txdb <- makeTxDbFromGFF(gtf_path)
# Create row id in m6a dataframe for ID matching
data.site_proba_df$row_id <- 1:nrow(data.site_proba_df)
# Convert m6a df to GRanges object
m6a_gr <- GRanges(
seqnames = data.site_proba_df$ensembl_transcript_id,
ranges = IRanges(
start = as.numeric(data.site_proba_df$transcript_position),
end = as.numeric(data.site_proba_df$transcript_position)
)
)
names(m6a_gr) <- data.site_proba_df$ensembl_transcript_id
# Extract exon-based transcript structure from the TxDb
transcripts_granges_list <- exonsBy(txdb, by = "tx")
# Get ALL transcript-level annotations from the TxDb
all_transcripts_df <- AnnotationDbi::select(
txdb,
keys = names(transcripts_granges_list), # Use the internal IDs as keys
columns = "TXNAME",                    # Request the actual transcript names
keytype = "TXID"
)
# Create a mapping vector: [Internal ID] -> [Actual TXNAME]
id_map <- all_transcripts_df$TXNAME
names(id_map) <- all_transcripts_df$TXID
# Assign the actual transcript names to the GRangesList
names(transcripts_granges_list) <- id_map[names(transcripts_granges_list)]
# Run the mapping function
m6a_gr_genomic_coords <- mapFromTranscripts(m6a_gr, transcripts_granges_list)
# Convert to Data Frame
m6a_gr_genomic_coords <- as.data.frame(m6a_gr_genomic_coords, row.names = NULL)
# Merge the original m6A data to keep all columns
# This requires a unique ID for each m6A site, which the 'queryHits' column provides.
m6a_gr_genomic_coords$query_hit_id <- 1:nrow(m6a_gr_genomic_coords)
# Prepare the Merged m6A Data with Genomic Coordinates
# The 'xHits' column in final_genomic_df corresponds to the row index
# in the original m6a_gr_genomic_coords (which is the same order as data.site_proba_df).
# We will use the 'xHits' column to merge the data.
m6a_gr_genomic_coords <- m6a_gr_genomic_coords %>%
# Select and rename columns for clarity
select(
chr = seqnames,
genomic_pos = start, # Position is start
strand,
original_m6a_row_index = xHits # The index of the row in the original df
) %>%
# Join back to the original m6A data frame to get the transcript ID
mutate(
ensembl_transcript_id = data.site_proba_df$ensembl_transcript_id[original_m6a_row_index]
)
# merge with original m6A df
merged_genomic_coords <- merge(
data.site_proba_df,
m6a_gr_genomic_coords,
by.x = c("ensembl_transcript_id", "row_id"),
by.y = c("ensembl_transcript_id", "original_m6a_row_index")
)
# create bed file for m6a (genomic coord, and m6a probability)
bed_df <- merged_genomic_coords %>%
mutate(
start = genomic_pos - 1, # 0-based
end = genomic_pos,
score = mod_ratio * 1000 # Should be between 0 and 1000 for IGV color scaling
) %>%
select(
chr,
start,
end,
name = ensembl_gene_name,
score,
strand
)
bedgraph_df <- merged_genomic_coords %>%
transmute(
chr,
start = genomic_pos - 1, # 0-based
end = genomic_pos,
score = mod_ratio # make the mod ratio the score
)
# write files
if (!is.null(output_bed)) {
write.table(bed_df,
file = output_bed,
sep = "\t",
quote = FALSE,
row.names = FALSE,
col.names = FALSE)
}
if (!is.null(output_bedgraph)) {
write.table(bedgraph_df,
file = output_bedgraph,
sep = "\t",
quote = FALSE,
row.names = FALSE,
col.names = FALSE)
}
# return bed file as object
return(output_bed)
}
annotate_m6A <- function(
m6a_df,
annotation_df,
annotation_type = "custom",       # e.g., "RBP", "miRNA", "SNP", "custom"
m6a_cols = c(chr="chr", start="start", end="end", strand="strand", name="name", score="score"),
ann_cols = c(chr="chr", start="start", end="end", strand="strand", name="name", score="score"),
zero_based = TRUE,
ignore_strand = FALSE
) {
# Convert m6A to GRanges
m6a_gr <- GRanges(
seqnames = m6a_df[[m6a_cols["chr"]]],
ranges = IRanges(
start = if(zero_based) m6a_df[[m6a_cols["start"]]] + 1 else m6a_df[[m6a_cols["start"]]],
end   = m6a_df[[m6a_cols["end"]]]
),
strand = if("strand" %in% names(m6a_df)) m6a_df[[m6a_cols["strand"]]] else "*",
mcols = m6a_df[, setdiff(names(m6a_df), c(m6a_cols, "chr", "start", "end", "strand")), drop=FALSE]
)
# Convert annotations to GRanges
ann_gr <- GRanges(
seqnames = annotation_df[[ann_cols["chr"]]],
ranges = IRanges(
start = if(zero_based) annotation_df[[ann_cols["start"]]] + 1 else annotation_df[[ann_cols["start"]]],
end   = annotation_df[[ann_cols["end"]]]
),
strand = if("strand" %in% names(annotation_df)) annotation_df[[ann_cols["strand"]]] else "*",
mcols = annotation_df[, setdiff(names(annotation_df), c(ann_cols, "chr", "start", "end", "strand")), drop=FALSE]
)
# Find overlaps in genomic coordinates
overlaps <- findOverlaps(m6a_gr, ann_gr, ignore.strand = ignore_strand)
if(length(overlaps) == 0){
message("No overlaps detected.")
return(NULL)
}
# Extract indices
m6a_idx <- queryHits(overlaps)
ann_idx <- subjectHits(overlaps)
# Create summarized dataframe
overlap_df <- data.frame(
m6A_index = m6a_idx,
annotation_name = if("name" %in% colnames(mcols(ann_gr))) ann_gr$name[ann_idx] else NA,
annotation_type = annotation_type,
stringsAsFactors = FALSE
)
# Optional: add metadata columns from annotation
extra_cols <- setdiff(colnames(mcols(ann_gr)), "name")
if(length(extra_cols) > 0){
overlap_df <- cbind(overlap_df, as.data.frame(mcols(ann_gr)[ann_idx, extra_cols, drop=FALSE]))
}
# Summarize per m6A site
summary_df <- overlap_df %>%
group_by(m6A_index) %>%
summarise(
Overlapping_Features = paste(unique(annotation_name), collapse="; "),
Feature_Count = n_distinct(annotation_name),
.groups = "drop"
)
return(summary_df)
}
browseVignettes(package = "IsoformSwitchAnalyzeR")
usethis::use_vignette("m6AnetTools")
usethis::use_vignette("m6AnetTools")
exists("delta", inherits = TRUE)
getAnywhere(delta)
list.files("vignettes")
usethis::use_vignette("m6AnetTools")
usethis::use_vignette("m6AnetTools")
pooled_igf <- read.csv("/Users/hannalee2002/hl_cell-lines-project/m6A/m6A_output/cell_lines_m6anet_output/RNA_cell_igf_all/pooled_igf_2025_m6a.csv")
devtools::load_all()
igf_all_bed <- create_bed_file(pooled_igf,
gtf_path = "/Users/hannalee2002/references/gencode/v45/gencode.v45.primary_assembly.annotation.gtf",
output_bedgraph = "/Users/hannalee2002/hl_cell-lines-project/all_igf.bedgraph")
naive1 <- read.csv("/Users/hannalee2002/hl_cell-lines-project/m6A/m6A_output/individual_m6anet_output/RNA_cell_naive1/data.site_proba_split.csv")
naive2 <- read.csv("/Users/hannalee2002/hl_cell-lines-project/m6A/m6A_output/individual_m6anet_output/RNA_cell_naive2/data.site_proba_split.csv")
naive3 <- read.csv("/Users/hannalee2002/hl_cell-lines-project/m6A/m6A_output/individual_m6anet_output/RNA_cell_naive3/data.site_proba_split.csv")
igf1 <- read.csv("/Users/hannalee2002/hl_cell-lines-project/m6A/m6A_output/individual_m6anet_output/RNA_cell_igf1/data.site_proba_split.csv")
igf2 <- read.csv("/Users/hannalee2002/hl_cell-lines-project/m6A/m6A_output/individual_m6anet_output/RNA_cell_igf2/data.site_proba_split.csv")
