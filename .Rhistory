library(dplyr)
duplicate_chr_genes <- pooled_naive_with_annotations %>%
group_by(ensembl_gene_id_noversion) %>%
# Summarize to get the count of unique chromosomes per gene
summarise(Unique_CHR_Count = n(), .groups = 'drop') %>%
# Filter for genes with more than one unique chromosome
filter(Unique_CHR_Count > 1)
View(duplicate_chr_genes)
duplicate_chr_genes <- pooled_naive_with_annotations %>%
group_by(ensembl_gene_id_noversion, chromosome_name) %>%
summarize(n=n())
summarize(n=n()
)
duplicate_chr_genes <- pooled_naive_with_annotations %>%
group_by(ensembl_gene_id_noversion, chromosome_name) %>%
summarize(n=n()) %>%
group_by(ensembl_gene_id_noversion) %>%
summarize(n=n())
View(pooled_naive_with_annotations)
m6Anet_bed <- pooled_naive_with_annotations %>%
dplyr::select(
transcript_id = ensembl_transcript_id, # Use Transcript ID as seqname
mod_start = transcript_position,       # Position of the modification within the transcript
mod_end = transcript_position,         # Same position
genome_chr = chromosome_name,                      # Chromosome (Genomic)
genome_strand = strand                 # Strand (Genomic)
) %>%
# Filter out rows that failed the BioMart lookup (NA chromosome)
dplyr::filter(!is.na(genome_chr))
gr_transcript_space <- GRanges(
seqnames = m6Anet_bed$transcript_id,  # CRITICAL: Must be the Transcript ID
ranges = IRanges(start = m6Anet_bed$mod_start,
end = m6Anet_bed$mod_end),
# Strand should be relative to the transcript, but since GFF3 files define strand globally,
# we can use the genomic strand here, or simplify to '*' if mapFromTranscripts handles it.
# For now, we'll keep it simple:
strand = "*"
)
# Load the annotation file to create the Transcript Database (TxDb)
# Ensure 'annotation.gff3' is in your working directory or provide the full path
txdb <- makeTxDbFromGFF("/Users/hannalee2002/references/gencode/v45/gencode.v45.primary_assembly.annotation.gtf")
# Isolate transcripts grouped by gene ID (this is correct)
transcripts_by_gene <- transcriptsBy(txdb, by = c("gene"))
# Use mapFromTranscripts to convert coordinates
# map2genome is a GRanges object containing the *genomic coordinates*
map2genome <- mapFromTranscripts(gr_transcript_space, transcripts_by_gene)
ead(names(transcripts_by_gene))
head(names(transcripts_by_gene))
## Attempt 2:
naive_gr_transcript_coordinates <- GRanges(
seqnames = pooled_naive$ensembl_transcript_id,
ranges = IRanges(
start = as.numeric(pooled_naive$transcript_position),
end = as.numeric(pooled_naive$transcript_position)
)
)
names(naive_gr_transcript_coordinates) <- pooled_naive$ensembl_transcript_id
# Extract exon-based transcript structure from the TxDb
transcripts_granges_list <- exonsBy(txdb, by = "tx")
# Get ALL transcript-level annotations from the TxDb
all_transcripts_df <- AnnotationDbi::select(
txdb,
keys = names(transcripts_granges_list), # Use the internal IDs as keys
columns = "TXNAME",                    # Request the actual transcript names
keytype = "TXID"
)
# Create a mapping vector: [Internal ID] -> [Actual TXNAME]
id_map <- all_transcripts_df$TXNAME
names(id_map) <- all_transcripts_df$TXID
# Assign the actual transcript names to the GRangesList
names(transcripts_granges_list) <- id_map[names(transcripts_granges_list)]
View(transcripts_granges_list)
# Step 3: Run the mapping function
naive_gr_genomic_coords <- mapFromTranscripts(naive_gr_transcript_coordinates, transcripts_granges_list)
# 5. Convert to Data Frame
naive_gr_genomic_coords <- as.data.frame(naive_gr_genomic_coords, row.names = NULL)
View(naive_gr_genomic_coords)
# Final step: Merge the original m6A data to keep all columns
# This requires a unique ID for each m6A site, which the 'queryHits' column provides.
naive_gr_genomic_coords$query_hit_id <- 1:nrow(naive_gr_genomic_coords)
# We will use the 'xHits' column to merge the data.
naive_gr_genomic_coords <- naive_gr_genomic_coords %>%
# Select and rename columns for clarity
select(
chr = seqnames,
genomic_pos = start, # Position is start
strand,
original_m6a_row_index = xHits # The index of the row in the original df
) %>%
# Join back to the original m6A data frame to get the transcript ID
mutate(
ensembl_transcript_id = pooled_naive$ensembl_transcript_id[original_m6a_row_index]
)
## Attempt 2:
#create row id in pooled_naive
pooled_naive$row_id <- 1:nrow(pooled_naive)
View(pooled_naive)
naive_gr_transcript_coordinates <- GRanges(
seqnames = pooled_naive$ensembl_transcript_id,
ranges = IRanges(
start = as.numeric(pooled_naive$transcript_position),
end = as.numeric(pooled_naive$transcript_position)
)
)
names(naive_gr_transcript_coordinates) <- pooled_naive$ensembl_transcript_id
# Extract exon-based transcript structure from the TxDb
transcripts_granges_list <- exonsBy(txdb, by = "tx")
# Get ALL transcript-level annotations from the TxDb
all_transcripts_df <- AnnotationDbi::select(
txdb,
keys = names(transcripts_granges_list), # Use the internal IDs as keys
columns = "TXNAME",                    # Request the actual transcript names
keytype = "TXID"
)
# Create a mapping vector: [Internal ID] -> [Actual TXNAME]
id_map <- all_transcripts_df$TXNAME
names(id_map) <- all_transcripts_df$TXID
# Assign the actual transcript names to the GRangesList
names(transcripts_granges_list) <- id_map[names(transcripts_granges_list)]
# Step 3: Run the mapping function
naive_gr_genomic_coords <- mapFromTranscripts(naive_gr_transcript_coordinates, transcripts_granges_list)
# 5. Convert to Data Frame
naive_gr_genomic_coords <- as.data.frame(naive_gr_genomic_coords, row.names = NULL)
# Final step: Merge the original m6A data to keep all columns
# This requires a unique ID for each m6A site, which the 'queryHits' column provides.
naive_gr_genomic_coords$query_hit_id <- 1:nrow(naive_gr_genomic_coords)
# 1. Prepare the Merged m6A Data with Genomic Coordinates
# The 'xHits' column in final_genomic_df corresponds to the row index
# in the original AA_gr_transcript_coords (which is the same order as astro_filtered_m6a_df).
# We will use the 'xHits' column to merge the data.
naive_gr_genomic_coords <- naive_gr_genomic_coords %>%
# Select and rename columns for clarity
select(
chr = seqnames,
genomic_pos = start, # Position is start
strand,
original_m6a_row_index = xHits # The index of the row in the original df
) %>%
# Join back to the original m6A data frame to get the transcript ID
mutate(
ensembl_transcript_id = pooled_naive$ensembl_transcript_id[original_m6a_row_index]
)
# merge with original m6A df
merged_naive_m6a_with_genomic_coords <- merge(
pooled_naive,
naive_gr_genomic_coords,
by.y = c("ensembl_transcript_id", "original_m6a_row_index", "chr"),
by.x = c("ensembl_transcript_id", "row_id", "chr")
)
# merge with original m6A df
merged_naive_m6a_with_genomic_coords <- merge(
pooled_naive,
naive_gr_genomic_coords,
by.y = c("ensembl_transcript_id", "original_m6a_row_index"),
by.x = c("ensembl_transcript_id", "row_id")
)
View(merged_naive_m6a_with_genomic_coords)
colnames(merged_naive_m6a_with_genomic_coords)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000
strand=strand,
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000
strand=strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000
strand=strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
colnames(merged_naive_m6a_with_genomic_coords)
# merge with original m6A df
merged_naive_m6a_with_genomic_coords <- merge(
pooled_naive,
naive_gr_genomic_coords,
by.y = c("ensembl_transcript_id", "original_m6a_row_index"),
by.x = c("ensembl_transcript_id", "row_id")
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
View(merged_naive_m6a_with_genomic_coords)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start=genomic_pos-1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
colnames(merged_naive_m6a_with_genomic_coords)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
start = genomic_pos - 1,
end=genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
chr=chr,
genomic_pos,
name = ensembl_gene_name,
score=mod_ratio *1000,
strand=strand
)
"genomic_pos" %in% colnames(merged_naive_m6a_with_genomic_coords)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
# BED Field 1: Chromosome
chr = chr,
# BED Field 2: Start (0-based)
# Subtract 1 from the 1-based genomic_pos
start = genomic_pos - 1,
# BED Field 3: End (1-based, half-open)
# The end coordinate is the 1-based position itself
end = genomic_pos,
# BED Field 4: Name (Required identifier)
name = ensembl_gene_name,
# BED Field 5: Score (Scaled 0-1000 for IGV color)
score = mod_ratio * 1000,
# BED Field 6: Strand
strand = strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
dplyr::select(
# BED Field 1: Chromosome
chr = chr,
# BED Field 2: Start (0-based)
# Subtract 1 from the 1-based genomic_pos
start = "genomic_pos" - 1,
# BED Field 3: End (1-based, half-open)
# The end coordinate is the 1-based position itself
end = genomic_pos,
# BED Field 4: Name (Required identifier)
name = ensembl_gene_name,
# BED Field 5: Score (Scaled 0-1000 for IGV color)
score = mod_ratio * 1000,
# BED Field 6: Strand
strand = strand
)
# create bed file for m6a (genomic coord, and m6a probability)
naive_bed <- merged_naive_m6a_with_genomic_coords %>%
mutate(
start = genomic_pos - 1,
end = genomic_pos,
score = mod_ratio * 1000
) %>%
select(
chr,
start,
end,
name = ensembl_gene_name,
score,
strand
)
View(naive_bed)
output_file <- "pooled_naive_m6a_genomic_igv.bed"
write.table(naive_bed,
file = output_file,
sep = "\t",
quote = FALSE,
row.names = FALSE,
col.names = FALSE)
problem_rows <- naive_bed %>%
dplyr::filter(is.na(name) | is.na(score) | is.na(strand))
str(naive_bed)
naive_bedgraph <- merged_naive_m6a_with_genomic_coords %>%
transmute(
chr,
start = genomic_pos - 1,
end = genomic_pos,
score = mod_ratio
)
write_tsv(naive_bedgraph, "naive_m6A_ratio.bedgraph", col_names = FALSE)
write.table(
naive_bedgraph,
file = "naive_m6A_ratio.bedgraph",
sep = "\t",
quote = FALSE,
row.names = FALSE,
col.names = FALSE
)
filt_pooled_naive <- filter_m6a_sites(pooled_naive)
library(m6ASeqTools)
filt_pooled_naive <- filter_m6a_sites(pooled_naive)
sites_per_tx <- filt_pooled_naive %>%
group_by(ensembl_transcript_id) %>%
summarize(n=n())
View(sites_per_tx)
View(sites_per_tx)
sites_per_tx <- filt_pooled_naive %>%
group_by(ensembl_transcript_name) %>%
summarize(n=n())
sites_per_tx <- pooled_naive %>%
group_by(ensembl_transcript_name) %>%
summarize(n=n())
View(sites_per_tx)
#' Load built-in RBP annotation
#'
#' @param organism "human" or "mouse"
#' @return GRanges object of RBP binding sites
#' @export
load_RBP_annotation <- function(organism = c("human", "mouse")) {
organism <- match.arg(organism)
file <- switch(organism,
"human" = system.file("extdata", "human_RBP_hg38.bed", package = "m6ASeqTools"),
"mouse" = system.file("extdata", "mouse_RBP_mm10.bed", package = "m6ASeqTools")
)
rtracklayer::import(file)
}
human_rbp_annotation <- load_RBP_annotation("human")
rbp_human_df <- readr::read_tsv(
"/Users/hannalee2002/Downloads/POSTAR3_downloads/human.txt",
col_names = c(
"chrom", "start", "end", "peak_id", "strand",
"rbp", "method", "sample", "accession", "score"
)
)
head(rbp_human_df)
# Convert m6A data to GRanges
# Start is 0-based in the file, but GRanges expects 1-based data,
# so we use start + 1 for the 1-based coordinate.
naive_bed_1_based_coord <- GRanges(
seqnames = naive_bed$chr,
ranges = IRanges(start = naive_bed$start + 1,
end = naive_bed$end),
strand = naive_bed$strand,
m6a_name = naive_bed$name,
m6a_score = naive_bed$score
)
rbp_human_gr <- GRanges(
seqnames = rbp_human_df$chrom,
ranges = IRanges(start = rbp_human_df$start,
end = rbp_human_df$end),
# Strand is important for RBP binding
strand = rbp_human_df$strand,
# Add RBP information as metadata
rbp_name = rbp_human_df$rbp,
rbp_method = rbp_human_df$method,
rbp_accession = rbp_human_df$accession,
rbp_score = rbp_human_df$score
)
rbp_human_gr <- GRanges(
seqnames = rbp_human_df$chrom,
ranges = IRanges(start = rbp_human_df$start + 1, # convert from 0-based to 1-based
end = rbp_human_df$end),
# Strand is important for RBP binding
strand = rbp_human_df$strand,
# Add RBP information as metadata
rbp_name = rbp_human_df$rbp,
rbp_method = rbp_human_df$method,
rbp_accession = rbp_human_df$accession,
rbp_score = rbp_human_df$score
)
# Find overlaps between m6A sites (query) and RBP sites (subject)
# 'ignore.strand=FALSE' is critical, as RBP binding is strand-specific.
overlaps <- findOverlaps(query = naive_m6A_gr,
subject = rbp_human_gr,
ignore.strand = FALSE)
# Convert m6A data to GRanges
# Start is 0-based in the file, but GRanges expects 1-based data,
# so we use start + 1 for the 1-based coordinate.
naive_m6A_gr <- GRanges(
seqnames = naive_bed$chr,
ranges = IRanges(start = naive_bed$start + 1, # convert 0-based to 1-based
end = naive_bed$end),
strand = naive_bed$strand,
m6a_name = naive_bed$name,
m6a_score = naive_bed$score
)
# Find overlaps between m6A sites (query) and RBP sites (subject)
# 'ignore.strand=FALSE' is critical, as RBP binding is strand-specific.
overlaps <- findOverlaps(query = naive_m6A_gr,
subject = rbp_human_gr,
ignore.strand = FALSE)
# Extract the indices:
# queryHits are the row numbers in the m6a_gr object (your m6A sites)
m6a_indices <- queryHits(overlaps)
# subjectHits are the row numbers in the rbp_gr object (the RBP sites)
rbp_indices <- subjectHits(overlaps)
length(m6a_indices)
nrow(naive_m6A_gr)
length(naive_m6A_gr)
# 1. Create a data frame containing only the overlapping records
overlap_df <- data.frame(
# Unique identifier for the m6A site that overlapped
m6a_row_index = m6a_indices,
# Metadata from the overlapping RBP site
RBP_Name = rbp_gr$rbp_name[rbp_indices],
RBP_Method = rbp_gr$rbp_method[rbp_indices],
RBP_Accession = rbp_gr$rbp_accession[rbp_indices]
) %>%
# Group by the m6A site index and summarize the RBP data
group_by(m6a_row_index) %>%
dplyr::summarise(
# Create a comma-separated list of all overlapping RBPs for that m6A site
Overlapping_RBPs = paste(unique(RBP_Name), collapse = "; "),
# Count how many unique RBPs overlap the site
RBP_Count = n_distinct(RBP_Name),
.groups = 'drop'
)
# 1. Create a data frame containing only the overlapping records
overlap_df <- data.frame(
# Unique identifier for the m6A site that overlapped
m6a_row_index = m6a_indices,
# Metadata from the overlapping RBP site
RBP_Name = rbp_human_gr$rbp_name[rbp_indices],
RBP_Method = rbp_human_gr$rbp_method[rbp_indices],
RBP_Accession = rbp_human_gr$rbp_accession[rbp_indices]
) %>%
# Group by the m6A site index and summarize the RBP data
group_by(m6a_row_index) %>%
dplyr::summarise(
# Create a comma-separated list of all overlapping RBPs for that m6A site
Overlapping_RBPs = paste(unique(RBP_Name), collapse = "; "),
# Count how many unique RBPs overlap the site
RBP_Count = n_distinct(RBP_Name),
.groups = 'drop'
)
View(overlap_df)
isu_all <- read.csv("/Users/hannalee2002/hl_cell-lines-project/cell-lines-ISU/all_ISU_KD_naive.csv")
head(isu_all)
isu_alk_naive <- isu_all %>%
filter(condition_1 == "ALK", condition_2 = "NAIVE")
isu_alk_naive <- isu_all %>%
filter(condition_1 == "ALK", condition_2 == "NAIVE")
isu_igf_naive <- isu_all %>%
filter(condition_1 == "IGF", condition_2 == "NAIVE")
isu_naive <- su_all %>%
filter(condition_2 == "NAIVE")
isu_naive <- isu_all %>%
filter(condition_2 == "NAIVE")
ggplot(data=isu_naive, aes(x=gene_log2_fold_change, y=dIF)) +
geom_point(
aes( color=abs(dIF) > 0.1 & isoform_switch_q_value < 0.05 ), # default cutoff
size=1
) +
facet_wrap(~ condition_2) +
#facet_grid(condition_1 ~ condition_2) + # alternative to facet_wrap if you have overlapping conditions
geom_hline(yintercept = 0, linetype='dashed') +
geom_vline(xintercept = 0, linetype='dashed') +
scale_color_manual('Signficant\nIsoform Switch', values = c('black','red')) +
labs(x='Gene log2 fold change', y='dIF') +
theme_bw()
library(ggplot2)
library(ggplot2)
p<-ggplot(data=isu_naive, aes(x=gene_log2_fold_change, y=dIF)) +
geom_point(
aes( color=abs(dIF) > 0.1 & isoform_switch_q_value < 0.05 ), # default cutoff
size=1
) +
facet_wrap(~ condition_2) +
#facet_grid(condition_1 ~ condition_2) + # alternative to facet_wrap if you have overlapping conditions
geom_hline(yintercept = 0, linetype='dashed') +
geom_vline(xintercept = 0, linetype='dashed') +
scale_color_manual('Signficant\nIsoform Switch', values = c('black','red')) +
labs(x='Gene log2 fold change', y='dIF') +
theme_bw()
